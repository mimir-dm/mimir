//! Load tester CLI for 5etools splitter archives
//!
//! This tool validates that tar.gz files generated by mimir-5esplit
//! can be successfully parsed and imported into a database.

use anyhow::Result;
use clap::{Parser, Subcommand};
use colored::*;
use mimir_5etools_splitter::load_tester::{LoadTester, TestSummary};
use std::path::PathBuf;

/// Test 5etools splitter archives for database import compatibility
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[command(subcommand)]
    command: Commands,

    /// Enable verbose logging
    #[arg(short, long, global = true)]
    verbose: bool,

    /// Output results as JSON
    #[arg(short, long, global = true)]
    json: bool,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Test a single archive file
    Test {
        /// Path to the tar.gz archive file
        #[arg(value_name = "ARCHIVE")]
        archive: PathBuf,
    },
    /// Test all archives in a directory
    TestAll {
        /// Directory containing tar.gz archive files
        #[arg(value_name = "DIRECTORY")]
        directory: PathBuf,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    // Setup logging
    let log_level = if args.verbose { "debug" } else { "info" };
    tracing_subscriber::fmt().with_env_filter(log_level).init();

    let tester = LoadTester::new(args.verbose);

    let summary = match args.command {
        Commands::Test { archive } => {
            if !archive.exists() {
                eprintln!("{} Archive not found: {:?}", "Error:".red().bold(), archive);
                std::process::exit(1);
            }

            if !archive.is_file() {
                eprintln!(
                    "{} Path is not a file: {:?}",
                    "Error:".red().bold(),
                    archive
                );
                std::process::exit(1);
            }

            if archive.extension().is_none_or(|ext| ext != "gz") {
                eprintln!(
                    "{} File is not a .tar.gz archive: {:?}",
                    "Error:".red().bold(),
                    archive
                );
                std::process::exit(1);
            }

            println!(
                "{} Testing single archive: {}",
                "ðŸ§ª".bright_blue(),
                archive.display().to_string().bright_white()
            );

            let result = tester.test_archive(&archive).await?;
            let mut summary = TestSummary::new();
            summary.add_result(result);
            summary
        }

        Commands::TestAll { directory } => {
            if !directory.exists() {
                eprintln!(
                    "{} Directory not found: {:?}",
                    "Error:".red().bold(),
                    directory
                );
                std::process::exit(1);
            }

            if !directory.is_dir() {
                eprintln!(
                    "{} Path is not a directory: {:?}",
                    "Error:".red().bold(),
                    directory
                );
                std::process::exit(1);
            }

            println!(
                "{} Testing all archives in directory: {}",
                "ðŸ§ª".bright_blue(),
                directory.display().to_string().bright_white()
            );

            tester.test_directory(&directory).await?
        }
    };

    // Output results
    if args.json {
        let json_output = serde_json::to_string_pretty(&summary)?;
        println!("{}", json_output);
    } else {
        summary.print_summary(args.verbose);
    }

    // Exit with appropriate code
    if summary.failed_archives > 0 {
        std::process::exit(1);
    }

    Ok(())
}
