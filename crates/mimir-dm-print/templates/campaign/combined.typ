// Mimir Print System - Combined Campaign Export Template
// Renders all campaign documents as a single PDF with cover and table of contents

#import "/_shared/styles.typ": *
#import "/_shared/components.typ": stat-block, monster-card-inline, ability-mod

// Expected data structure (injected by PrintService):
// - campaign_name: Name of the campaign (string)
// - documents: Array of document objects, each with:
//   - title: Document title
//   - document_type: Type (e.g., "session_outline")
//   - content: Pre-converted Typst content
// - modules: Array of module objects (optional), each with:
//   - name: Module name
//   - module_number: Module number
//   - monsters: Array of monster data objects

#let campaign-name = data.at("campaign_name", default: "Campaign Documents")
#let documents-raw = data.at("documents", default: ())
#let documents = if documents-raw == none { () } else { documents-raw }
#let modules-raw = data.at("modules", default: ())
#let modules = if modules-raw == none { () } else { modules-raw }

// Format document type for display
#let format-type(doc-type) = {
  doc-type.replace("_", " ").split(" ").map(word => {
    if word.len() > 0 {
      upper(word.at(0)) + word.slice(1)
    } else {
      word
    }
  }).join(" ")
}

// Group documents by type
#let group-documents(docs) = {
  let groups = (:)
  for doc in docs {
    let doc-type = doc.at("document_type", default: "other")
    if doc-type not in groups {
      groups.insert(doc-type, ())
    }
    groups.at(doc-type).push(doc)
  }
  groups
}

// Base page setup (no header/footer for cover page)
#set page(
  paper: "us-letter",
  margin: (top: 1in, bottom: 0.75in, left: 0.75in, right: 0.75in),
)

// Base text settings
#set text(
  font: font-body,
  size: sizes.base,
  fill: colors.text,
)

// Heading styles
#show heading.where(level: 1): it => {
  v(spacing.lg)
  text(size: sizes.xxl, weight: "bold", font: font-heading, it.body)
  v(spacing.md)
}

#show heading.where(level: 2): it => {
  v(spacing.md)
  text(size: sizes.xl, weight: "bold", font: font-heading, it.body)
  v(spacing.sm)
}

#show heading.where(level: 3): it => {
  v(spacing.sm)
  text(size: sizes.lg, weight: "bold", font: font-heading, it.body)
  v(spacing.xs)
}

// Paragraph settings
#set par(
  leading: 0.65em,
  justify: true,
  first-line-indent: 0pt,
)

// List settings
#set list(
  indent: 1em,
  body-indent: 0.5em,
)

#set enum(
  indent: 1em,
  body-indent: 0.5em,
)

// Blockquote styling
#show quote: it => {
  block(
    width: 100%,
    inset: (left: 1em, y: 0.5em),
    stroke: (left: 2pt + colors.border-light),
    fill: colors.background-alt,
  )[
    #set text(style: "italic")
    #it.body
  ]
}

// =============================================================================
// COVER PAGE (only shown when there are campaign-level documents)
// =============================================================================

#if documents.len() > 0 [
  #align(center + horizon)[
    #v(2in)

    #text(size: 36pt, weight: "bold", font: font-heading, campaign-name)

    #v(1in)

    #text(size: sizes.xl, fill: colors.text-secondary)[Campaign Documents]

    #v(2in)

    #line(length: 3in, stroke: 1pt + colors.border-light)

    #v(0.5in)

    #text(size: sizes.sm, fill: colors.text-secondary)[Generated by Mimir]
  ]

  #pagebreak()

  // ===========================================================================
  // TABLE OF CONTENTS
  // ===========================================================================

  = Table of Contents

  #v(spacing.lg)

  #for (i, doc) in documents.enumerate() [
    #let doc-title = doc.at("title", default: "Untitled")
    #let doc-type = doc.at("document_type", default: "document")
    #let formatted-type = format-type(doc-type)
    // Only show type if it's not redundant with the title
    #let show-type = not doc-title.contains(formatted-type) and formatted-type != doc-title

    #grid(
      columns: (1fr, auto),
      gutter: spacing.sm,
      [#str(i + 1). #doc-title],
      if show-type [#text(size: sizes.sm, fill: colors.text-secondary)[#formatted-type]] else []
    )
    #v(spacing.xs)
  ]

  #pagebreak()
]

// =============================================================================
// DOCUMENT PAGES
// =============================================================================

#for (i, doc) in documents.enumerate() [
  #let doc-title = doc.at("title", default: "Untitled")
  #let doc-type = doc.at("document_type", default: "document")
  #let content = doc.at("content", default: "")

  // Document type badge
  #set text(size: sizes.sm, fill: colors.text-secondary)
  #format-type(doc-type)

  // Document title
  #v(spacing.sm)
  #align(center)[
    #text(size: sizes.title, weight: "bold", font: font-heading, doc-title)
  ]

  #v(spacing.lg)

  // Document content
  #set text(size: sizes.base, fill: colors.text)
  #eval(content, mode: "markup")

  // Page break between documents (except after last)
  #if i < documents.len() - 1 [
    #pagebreak()
  ]
]

// =============================================================================
// MODULE MONSTER CARDS
// =============================================================================

// Helper to parse monster entries
#let parse-entries(entries) = {
  if entries == none { return () }
  entries.map(entry => {
    if type(entry) == str { (name: none, description: entry) } else if type(entry) == dictionary {
      let name = entry.at("name", default: none)
      let entry-entries-raw = entry.at("entries", default: ())
      let entry-entries = if entry-entries-raw == none { () } else { entry-entries-raw }
      let desc = if entry-entries.len() > 0 { entry-entries.filter(e => type(e) == str).join(" ") } else { "" }
      (name: name, description: desc)
    } else { (name: none, description: str(entry)) }
  }).filter(e => e.description != "" or e.name != none)
}

// Helper to extract monster data
#let extract-monster-data(monster) = {
  let monster-name = monster.at("name", default: "Unknown Monster")
  let quantity = monster.at("quantity", default: 1)
  let encounter-tag = monster.at("encounter_tag", default: none)

  // Size
  let size-data-raw = monster.at("size", default: ("M",))
  let size-data = if size-data-raw == none { ("M",) } else { size-data-raw }
  let monster-size = {
    if type(size-data) == array and size-data.len() > 0 {
      let s = size-data.at(0)
      if s == "T" { "Tiny" } else if s == "S" { "Small" } else if s == "M" { "Medium" } else if s == "L" { "Large" } else if s == "H" { "Huge" } else if s == "G" { "Gargantuan" } else { s }
    } else if type(size-data) == str { size-data } else { "Medium" }
  }

  // Type
  let type-data = monster.at("creature_type", default: "humanoid")
  let monster-type = {
    if type(type-data) == str { type-data } else if type(type-data) == dictionary {
      let base = type-data.at("type", default: "humanoid")
      let tags-raw = type-data.at("tags", default: ())
      let tags = if tags-raw == none { () } else { tags-raw }
      if tags.len() > 0 { base + " (" + tags.join(", ") + ")" } else { base }
    } else { "humanoid" }
  }

  // Alignment
  let align-data = monster.at("alignment", default: none)
  let monster-alignment = {
    if align-data == none { "unaligned" } else if type(align-data) == array {
      let abbrevs = align-data.map(a => {
        if type(a) == str {
          if a == "L" { "lawful" } else if a == "N" { "neutral" } else if a == "NX" { "neutral" } else if a == "NY" { "neutral" } else if a == "C" { "chaotic" } else if a == "G" { "good" } else if a == "E" { "evil" } else if a == "U" { "unaligned" } else if a == "A" { "any alignment" } else { a }
        } else { str(a) }
      })
      abbrevs.join(" ")
    } else if type(align-data) == str { align-data } else { "unaligned" }
  }

  // AC
  let ac-data = monster.at("ac", default: 10)
  let monster-ac = {
    if type(ac-data) == int { str(ac-data) } else if type(ac-data) == array and ac-data.len() > 0 {
      let first = ac-data.at(0)
      if type(first) == int { str(first) } else if type(first) == dictionary {
        let ac-val = first.at("ac", default: 10)
        let ac-from-raw = first.at("from", default: ())
        let ac-from = if ac-from-raw == none { () } else { ac-from-raw }
        if ac-from.len() > 0 { str(ac-val) } else { str(ac-val) }
      } else { "10" }
    } else { "10" }
  }

  // HP
  let hp-data = monster.at("hp", default: none)
  let monster-hp = {
    if hp-data == none { "1" } else if type(hp-data) == int { str(hp-data) } else if type(hp-data) == dictionary {
      let avg = hp-data.at("average", default: 1)
      str(avg)
    } else { "1" }
  }

  // Speed (simplified)
  let speed-data = monster.at("speed", default: none)
  let monster-speed = {
    if speed-data == none { "30 ft." } else {
      let walk = speed-data.at("walk", default: none)
      if walk != none and type(walk) == int { str(walk) + " ft." } else { "30 ft." }
    }
  }

  // Ability scores
  let str-score = monster.at("str", default: 10)
  let dex-score = monster.at("dex", default: 10)
  let con-score = monster.at("con", default: 10)
  let int-score = monster.at("int", default: 10)
  let wis-score = monster.at("wis", default: 10)
  let cha-score = monster.at("cha", default: 10)

  // CR
  let cr-data = monster.at("cr", default: "0")
  let monster-cr = {
    if type(cr-data) == str { cr-data } else if type(cr-data) == dictionary { cr-data.at("cr", default: "0") } else if type(cr-data) == int { str(cr-data) } else { "0" }
  }

  // Actions
  let actions = parse-entries(monster.at("action", default: ()))

  (
    name: monster-name,
    size: monster-size,
    type: monster-type,
    alignment: monster-alignment,
    ac: monster-ac,
    hp: monster-hp,
    speed: monster-speed,
    str: str-score,
    dex: dex-score,
    con: con-score,
    int: int-score,
    wis: wis-score,
    cha: cha-score,
    cr: monster-cr,
    quantity: quantity,
    encounter-tag: encounter-tag,
    actions: actions,
  )
}

// Track if we've rendered any content yet (for conditional pagebreak)
#let has-campaign-docs = documents.len() > 0

#for (module-index, module) in modules.enumerate() [
  #let module-name = module.at("name", default: "Unknown Module")
  #let module-number = module.at("module_number", default: 0)
  #let module-docs-raw = module.at("documents", default: ())
  #let module-docs = if module-docs-raw == none { () } else { module-docs-raw }
  #let monsters-raw = module.at("monsters", default: ())
  #let monsters = if monsters-raw == none { () } else { monsters-raw }

  // Separate session notes from other documents
  #let session-notes = module-docs.filter(doc => doc.at("document_type", default: "") == "session_notes")
  #let other-docs = module-docs.filter(doc => doc.at("document_type", default: "") != "session_notes")

  #if other-docs.len() > 0 or session-notes.len() > 0 or monsters.len() > 0 [
    // Only add pagebreak if there's prior content (campaign docs or previous modules)
    #if has-campaign-docs or module-index > 0 [
      #pagebreak()
    ]

    // Module heading
    = Module #module-number: #module-name

    // Render module documents first (excluding session notes)
    #for doc in other-docs [
      #let doc-title = doc.at("title", default: "Untitled")
      #let doc-type = doc.at("document_type", default: "document")
      #let content = doc.at("content", default: "")

      #v(spacing.md)

      // Document type badge
      #set text(size: sizes.sm, fill: colors.text-secondary)
      #format-type(doc-type)

      // Document title
      #v(spacing.xs)
      #text(size: sizes.lg, weight: "bold", font: font-heading)[#doc-title]

      #v(spacing.md)

      // Document content
      #set text(size: sizes.base, fill: colors.text)
      #eval(content, mode: "markup")

      #v(spacing.lg)
    ]

    // Always render Module Play Notes page (for physical note-taking)
    #pagebreak()

    #text(size: sizes.xl, weight: "bold", font: font-heading)[Module Play Notes]

    #v(spacing.lg)

    #if session-notes.len() > 0 [
      // Render existing session notes content
      #for note in session-notes [
        #let note-title = note.at("title", default: "Session Notes")
        #let content = note.at("content", default: "")

        // Note title
        #text(size: sizes.lg, weight: "bold", font: font-heading)[#note-title]

        #v(spacing.md)

        // Note content
        #set text(size: sizes.base, fill: colors.text)
        #eval(content, mode: "markup")

        #v(spacing.lg)
      ]
    ] else [
      // Placeholder for handwritten notes
      #text(size: sizes.base, fill: colors.text-secondary, style: "italic")[Use this page to record notes during play.]

      #v(spacing.xl)

      // Ruled lines for note-taking
      #for i in range(20) [
        #line(length: 100%, stroke: 0.5pt + colors.border-light)
        #v(1.5em)
      ]
    ]

    // Then render monster cards on a separate page
    #if monsters.len() > 0 [
      #pagebreak()

      #text(size: sizes.lg, weight: "bold")[Module #module-number Monsters]

      #v(spacing.md)

      #for monster in monsters [
        #let m = extract-monster-data(monster)

        #monster-card-inline(
          name: m.name,
          size: m.size,
          type: m.type,
          alignment: m.alignment,
          ac: m.ac,
          hp: m.hp,
          speed: m.speed,
          str: m.str,
          dex: m.dex,
          con: m.con,
          int: m.int,
          wis: m.wis,
          cha: m.cha,
          cr: m.cr,
          quantity: m.quantity,
          encounter-tag: m.encounter-tag,
          actions: m.actions,
        )

        #v(spacing.md)
      ]
    ]
  ]
]

// =============================================================================
// NPC CHARACTER SHEETS
// =============================================================================

#let npcs-raw = data.at("npcs", default: ())
#let npcs = if npcs-raw == none { () } else { npcs-raw }

// Helper to safely get nested data
#let get(obj, key, default: none) = {
  if obj != none and key in obj { obj.at(key) } else { default }
}

// Helper to calculate ability modifier
#let ability-mod-calc(score) = {
  calc.floor((score - 10) / 2)
}

// Helper to format modifier
#let fmt-mod(score) = {
  let mod = ability-mod-calc(score)
  if mod >= 0 { "+" + str(mod) } else { str(mod) }
}

// Calculate proficiency bonus from level
#let prof-bonus(level) = {
  if level <= 4 { 2 }
  else if level <= 8 { 3 }
  else if level <= 12 { 4 }
  else if level <= 16 { 5 }
  else { 6 }
}

#if npcs.len() > 0 [
  #pagebreak()

  = Campaign NPCs

  #for (npc-index, npc) in npcs.enumerate() [
    #let char-name = get(npc, "character_name", default: "Unknown NPC")
    #let level = get(npc, "level", default: 1)
    #let race = get(npc, "race", default: "Unknown")
    #let subrace = get(npc, "subrace", default: none)
    #let background = get(npc, "background", default: "Unknown")
    #let alignment = get(npc, "alignment", default: none)
    #let classes = get(npc, "classes", default: ())

    // NPC-specific fields
    #let npc-role = get(npc, "npc_role", default: none)
    #let npc-location = get(npc, "npc_location", default: none)
    #let npc-faction = get(npc, "npc_faction", default: none)
    #let npc-notes = get(npc, "npc_notes", default: none)

    // Build class string
    #let class-str = if classes.len() > 0 {
      classes.map(c => {
        let name = get(c, "class_name", default: "?")
        let lvl = get(c, "level", default: 0)
        let sub = get(c, "subclass", default: none)
        if sub != none { [#name (#sub) #lvl] } else { [#name #lvl] }
      }).join(" / ")
    } else { "Commoner" }

    // Race string with subrace
    #let race-str = if subrace != none { [#subrace #race] } else { race }

    // Ability scores
    #let abilities = get(npc, "abilities", default: (
      strength: 10,
      dexterity: 10,
      constitution: 10,
      intelligence: 10,
      wisdom: 10,
      charisma: 10,
    ))
    #let str-score = get(abilities, "strength", default: 10)
    #let dex-score = get(abilities, "dexterity", default: 10)
    #let con-score = get(abilities, "constitution", default: 10)
    #let int-score = get(abilities, "intelligence", default: 10)
    #let wis-score = get(abilities, "wisdom", default: 10)
    #let cha-score = get(abilities, "charisma", default: 10)

    // Combat stats
    #let max-hp = get(npc, "max_hp", default: 10)
    #let current-hp = get(npc, "current_hp", default: max-hp)
    #let speed = get(npc, "speed", default: 30)

    // Proficiencies
    #let proficiencies = get(npc, "proficiencies", default: ())
    #let prof-saves = get(proficiencies, "saves", default: ())
    #let prof-skills = get(proficiencies, "skills", default: ())
    #let prof-tools = get(proficiencies, "tools", default: ())
    #let prof-langs = get(proficiencies, "languages", default: ())

    // AC calculation
    #let equipped = get(npc, "equipped", default: ())
    #let has-shield = get(equipped, "shield", default: none) != none
    #let base-ac = 10 + ability-mod-calc(dex-score) + if has-shield { 2 } else { 0 }

    // Personality
    #let personality = get(npc, "personality", default: ())
    #let traits = get(personality, "traits", default: none)
    #let ideals = get(personality, "ideals", default: none)
    #let bonds = get(personality, "bonds", default: none)
    #let flaws = get(personality, "flaws", default: none)

    // Class features and feats
    #let class-features = get(npc, "class_features", default: ())
    #let feats = get(npc, "feats", default: ())
    #let class-features-details = get(npc, "class_features_details", default: ())
    #let subclass-features-details = get(npc, "subclass_features_details", default: ())

    // Helper to find feature details by name
    #let get-feature-description(feature-name) = {
      // First check class features
      let class-match = if type(class-features-details) == array {
        class-features-details.find((f) => get(f, "name", default: "") == feature-name)
      } else { none }

      if class-match != none {
        let entries = get(class-match, "entries", default: ())
        if type(entries) == array and entries.len() > 0 {
          // Extract first text entry as description
          let first-entry = entries.at(0)
          if type(first-entry) == str { first-entry }
          else { none }
        } else { none }
      } else {
        // Check subclass features
        let subclass-match = if type(subclass-features-details) == array {
          subclass-features-details.find((f) => get(f, "name", default: "") == feature-name)
        } else { none }

        if subclass-match != none {
          let entries = get(subclass-match, "entries", default: ())
          if type(entries) == array and entries.len() > 0 {
            let first-entry = entries.at(0)
            if type(first-entry) == str { first-entry }
            else { none }
          } else { none }
        } else { none }
      }
    }

    // Spells
    #let spells = get(npc, "spells", default: ())
    #let cantrips = get(spells, "cantrips", default: ())
    #let prepared = get(spells, "prepared_spells", default: ())
    #let known = get(spells, "known_spells", default: ())

    #v(spacing.lg)

    // =========================================================================
    // NPC HEADER
    // =========================================================================
    #block(
      width: 100%,
      inset: spacing.md,
      stroke: (bottom: 2pt + colors.accent),
    )[
      #grid(
        columns: (1fr, auto),
        [
          #text(size: sizes.xl, weight: "bold", font: font-heading)[#char-name]
          #linebreak()
          #text(size: sizes.md)[Level #level #race-str #class-str]
          #if background != "Unknown" or alignment != none [
            #linebreak()
            #text(size: sizes.sm, fill: colors.text-secondary)[
              #if background != "Unknown" [#background]
              #if alignment != none [, #alignment]
            ]
          ]
        ],
        [
          #box(
            fill: colors.accent,
            radius: 4pt,
            inset: (x: spacing.sm, y: spacing.xs),
          )[
            #text(fill: white, weight: "bold", size: sizes.sm)[NPC]
          ]
        ]
      )
    ]

    // =========================================================================
    // NPC INFO BOX (Role, Location, Faction, Notes)
    // =========================================================================
    #if npc-role != none or npc-location != none or npc-faction != none or npc-notes != none [
      #v(spacing.md)
      #block(
        width: 100%,
        fill: rgb("#fff8e1"),
        stroke: 1pt + colors.accent,
        radius: 4pt,
        inset: spacing.md,
      )[
        #text(weight: "bold", size: sizes.md)[NPC Information]
        #v(spacing.sm)

        #grid(
          columns: (1fr, 1fr),
          column-gutter: spacing.lg,
          row-gutter: spacing.sm,

          if npc-role != none [
            *Role:* #npc-role
          ],
          if npc-location != none [
            *Location:* #npc-location
          ],
          if npc-faction != none [
            *Faction:* #npc-faction
          ],
        )

        #if npc-notes != none [
          #v(spacing.sm)
          *DM Notes:* #text(size: sizes.sm)[#npc-notes]
        ]
      ]
    ]

    #v(spacing.md)

    // =========================================================================
    // ABILITY SCORES AND COMBAT
    // =========================================================================
    #grid(
      columns: (2fr, 1fr),
      column-gutter: spacing.md,

      // Ability Scores
      [
        #block(
          width: 100%,
          stroke: 1pt + colors.border-light,
          radius: 4pt,
          inset: spacing.sm,
        )[
          #text(weight: "bold", size: sizes.sm)[Ability Scores]
          #v(spacing.xs)
          #grid(
            columns: (1fr, 1fr, 1fr, 1fr, 1fr, 1fr),
            column-gutter: spacing.xs,
            ..("STR", "DEX", "CON", "INT", "WIS", "CHA").zip((str-score, dex-score, con-score, int-score, wis-score, cha-score)).map(((name, score)) => {
              align(center)[
                #text(size: sizes.xs, weight: "bold")[#name]
                #linebreak()
                #text(size: sizes.md)[#score]
                #linebreak()
                #text(size: sizes.sm, fill: colors.text-secondary)[#fmt-mod(score)]
              ]
            })
          )
        ]
      ],

      // Combat Stats
      [
        #block(
          width: 100%,
          stroke: 1pt + colors.border-light,
          radius: 4pt,
          inset: spacing.sm,
        )[
          #text(weight: "bold", size: sizes.sm)[Combat]
          #v(spacing.xs)
          #grid(
            columns: (1fr, 1fr),
            row-gutter: spacing.xs,
            [*HP:* #current-hp / #max-hp],
            [*AC:* #base-ac],
            [*Speed:* #speed ft],
            [*Prof:* +#prof-bonus(level)],
          )
        ]
      ],
    )

    #v(spacing.sm)

    // =========================================================================
    // PROFICIENCIES AND PERSONALITY
    // =========================================================================
    #grid(
      columns: (1fr, 1fr),
      column-gutter: spacing.md,

      // Proficiencies
      [
        #block(
          width: 100%,
          stroke: 1pt + colors.border-light,
          radius: 4pt,
          inset: spacing.sm,
        )[
          #text(weight: "bold", size: sizes.sm)[Proficiencies]
          #v(spacing.xs)

          #if prof-skills.len() > 0 [
            *Skills:* #text(size: sizes.sm)[#prof-skills.join(", ")]
            #linebreak()
          ]
          #if prof-langs.len() > 0 [
            *Languages:* #text(size: sizes.sm)[#prof-langs.join(", ")]
            #linebreak()
          ]
          #if prof-tools.len() > 0 [
            *Tools:* #text(size: sizes.sm)[#prof-tools.join(", ")]
          ]
          #if prof-skills.len() == 0 and prof-langs.len() == 0 and prof-tools.len() == 0 [
            #text(size: sizes.sm, fill: colors.text-secondary)[None listed]
          ]
        ]
      ],

      // Personality
      [
        #block(
          width: 100%,
          stroke: 1pt + colors.border-light,
          radius: 4pt,
          inset: spacing.sm,
        )[
          #text(weight: "bold", size: sizes.sm)[Personality]
          #v(spacing.xs)

          #if traits != none [
            *Traits:* #text(size: sizes.sm)[#traits]
            #v(spacing.xs)
          ]
          #if ideals != none [
            *Ideals:* #text(size: sizes.sm)[#ideals]
            #v(spacing.xs)
          ]
          #if bonds != none [
            *Bonds:* #text(size: sizes.sm)[#bonds]
            #v(spacing.xs)
          ]
          #if flaws != none [
            *Flaws:* #text(size: sizes.sm)[#flaws]
          ]
          #if traits == none and ideals == none and bonds == none and flaws == none [
            #text(size: sizes.sm, fill: colors.text-secondary)[None listed]
          ]
        ]
      ],
    )

    // =========================================================================
    // FEATURES AND SPELLS (if any)
    // =========================================================================
    #if class-features.len() > 0 or feats.len() > 0 or cantrips.len() > 0 or prepared.len() > 0 or known.len() > 0 [
      #v(spacing.sm)
      #grid(
        columns: (1fr, 1fr),
        column-gutter: spacing.md,

        // Features
        if class-features.len() > 0 or feats.len() > 0 [
          #block(
            width: 100%,
            stroke: 1pt + colors.border-light,
            radius: 4pt,
            inset: spacing.sm,
          )[
            #text(weight: "bold", size: sizes.sm)[Features & Traits]
            #v(spacing.xs)
            #if type(class-features) == array and class-features.len() > 0 [
              #for feature in class-features [
                #let feature-name = if type(feature) == dictionary { get(feature, "name", default: "?") } else { feature }
                #let feature-class = if type(feature) == dictionary { get(feature, "class_name", default: "") } else { "" }
                #let feature-subclass = if type(feature) == dictionary { get(feature, "subclass_name", default: none) } else { none }
                #let feature-level = if type(feature) == dictionary { get(feature, "level", default: 0) } else { 0 }
                #let feature-desc = get-feature-description(feature-name)

                #text(size: sizes.sm, weight: "bold")[#feature-name]
                #if feature-class != "" [
                  #text(size: sizes.xs, fill: colors.text-secondary)[ (#if feature-subclass != none [#feature-subclass] else [#feature-class] Lv#feature-level)]
                ]
                #linebreak()
                #if feature-desc != none [
                  #text(size: sizes.xs)[#feature-desc]
                  #v(spacing.xs)
                ]
              ]
            ]
            #if feats.len() > 0 [
              #v(spacing.xs)
              *Feats:* #text(size: sizes.sm)[#feats.join(", ")]
            ]
          ]
        ],

        // Spells
        if cantrips.len() > 0 or prepared.len() > 0 or known.len() > 0 [
          #block(
            width: 100%,
            stroke: 1pt + colors.border-light,
            radius: 4pt,
            inset: spacing.sm,
          )[
            #text(weight: "bold", size: sizes.sm)[Spellcasting]
            #v(spacing.xs)

            #if cantrips.len() > 0 [
              *Cantrips:* #text(size: sizes.sm)[#cantrips.map(s => if type(s) == dictionary { get(s, "name", default: "?") } else { s }).join(", ")]
              #v(spacing.xs)
            ]

            #let spell-list = if prepared.len() > 0 { prepared } else { known }
            #if spell-list.len() > 0 [
              *Spells:* #text(size: sizes.sm)[#spell-list.map(s => if type(s) == dictionary { get(s, "name", default: "?") } else { s }).join(", ")]
            ]
          ]
        ],
      )
    ]

    // =========================================================================
    // LEGENDARY ACTIONS (for boss NPCs)
    // =========================================================================
    #let legendary-actions = get(npc, "legendary_actions", default: ())
    #let legendary-count = get(npc, "legendary_action_count", default: none)

    #if legendary-actions.len() > 0 [
      #v(spacing.md)

      #block(
        width: 100%,
        fill: rgb("#fff3e0"),
        stroke: 1pt + rgb("#ff9800"),
        radius: 4pt,
        inset: spacing.md,
      )[
        #text(weight: "bold", size: sizes.md, fill: rgb("#e65100"))[Legendary Actions]
        #v(spacing.sm)

        #text(size: sizes.sm)[
          #char-name can take #if legendary-count != none { legendary-count } else { 3 } legendary actions, choosing from the options below. Only one legendary action can be used at a time and only at the end of another creature's turn. #char-name regains spent legendary actions at the start of its turn.
        ]

        #v(spacing.sm)

        #for action in legendary-actions [
          #let action-name = get(action, "name", default: "?")
          #let cost = get(action, "cost", default: 1)
          #let desc = get(action, "description", default: "")

          #text(weight: "bold", size: sizes.sm)[#action-name#if cost > 1 [ (Costs #cost Actions)]. ]
          #text(size: sizes.sm)[#desc]
          #linebreak()
        ]
      ]
    ]

    // Page break after each NPC (except the last)
    #if npc-index < npcs.len() - 1 [
      #pagebreak()
    ]
  ]
]

// =============================================================================
// CAMPAIGN MAPS
// =============================================================================

#let maps-raw = data.at("maps", default: ())
#let maps = if maps-raw == none { () } else { maps-raw }

#if maps.len() > 0 [
  #pagebreak()

  = Campaign Maps

  #for (map-index, map) in maps.enumerate() [
    #let map-name = map.at("name", default: "Unknown Map")
    #let grid-path = map.at("grid_path", default: none)
    #let has-tokens = map.at("has_tokens", default: false)
    #let tokens-path = map.at("tokens_path", default: none)

    // Map page with grid-only version (or just grid if no tokens)
    #if map-index > 0 [
      #pagebreak()
    ]

    #align(center)[
      #text(size: sizes.lg, weight: "bold", font: font-heading)[#map-name]
      #if has-tokens [
        #text(size: sizes.sm, fill: colors.text-secondary)[ (Grid Only)]
      ]
    ]

    #v(spacing.sm)

    #if grid-path != none [
      #align(center)[
        #image(
          grid-path,
          width: 100%,
          height: auto,
          fit: "contain",
        )
      ]
    ]

    // If tokens exist, add a second page with tokens
    #if has-tokens and tokens-path != none [
      #pagebreak()

      #align(center)[
        #text(size: sizes.lg, weight: "bold", font: font-heading)[#map-name]
        #text(size: sizes.sm, fill: colors.text-secondary)[ (With Tokens)]
      ]

      #v(spacing.sm)

      #align(center)[
        #image(
          tokens-path,
          width: 100%,
          height: auto,
          fit: "contain",
        )
      ]
    ]
  ]
]

// Footer on last page
#v(1fr)
#align(center)[
  #text(size: sizes.sm, fill: colors.text-secondary)[Generated by Mimir]
]
